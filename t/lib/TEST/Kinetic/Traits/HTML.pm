package TEST::Kinetic::Traits::HTML;

#use Class::Trait 'base';
# requires desired_attributes()

use strict;
use warnings;

# note that the following is a stop-gap measure until Class::Trait has
# a couple of bugs fixed.  Bugs have been reported back to the author.
#
# Traits would be useful here as the REST and REST::Dispatch classes are
# coupled, but not by inheritance.  The tests need to share functionality
# but since inheritance is not an option, I will be importing these methods
# directly into the required namespaces.

use Exporter::Tidy default => [
    qw/
      domain
      header_html
      instance_table
      path
      search_form
      url
      /
];

##############################################################################

=head1 Available methods

=head2 Instance methods

The following methods are are methods related to the production of HTML
documents.

=cut

##############################################################################

=head3 domain

 my $domain = $test->domain;
 $test->domain($domain);   

Getter/setter for test domain.  Domain in this context is actually the base
URL (without the base path).  For example:

 http://www.example.com/      # good
 http://www.example.com/rest/ # bad

Currently no validation is performed.

A trailing slash "C</>" will be added if not supplied.

=cut

sub domain {
    my $test = shift;
    return $test->{domain} unless @_;
    my $domain = shift;
    $domain .= '/' unless $domain =~ m{/$};
    $test->{domain} = $domain;
    return $test;
}

##############################################################################

=head3 path

 my $path = $test->path;
 $test->path($path);   

Getter/setter for test path.  Path in this context is actually the base
path (without the domain).  For example:

 rest/                        # good
 http://www.example.com/rest/ # bad

Currently no validation is performed.

A trailing slash "C</>" will be added if not supplied and if the path is
not the empty string or undefined.  A leading slash will be stripped.

The path will be set to the empty string if set with an undefined value.

=cut

sub path {
    my $test = shift;
    return $test->{path} unless @_;
    if ( defined( my $path = shift ) ) {
        $path .= '/' if $path && $path !~ m{/$};
        $path =~ s{^/}{}g;
        $test->{path} = $path;
    }
    else {
        $test->{path} = '';
    }
    return $test;
}

##############################################################################

=head3 url

  my $url = $test->url;

Returns the full URL for the test (C<$domain.$path>).

Will croak if the domain has not been set.

=cut

sub url {
    my $test = shift;
    unless ( defined $test->domain ) {
        require Carp;
        Carp::croak("Test domain not set.  Cannot create url");
    }
    return $test->domain . $test->path;
}

##############################################################################

=head3 header_html

  my $header = $test->html_header($title);

Returns the top portion of an HTML document generated by XSLT, up to and
including the body tag.

=cut

sub header_html {
    my ( $test, $title ) = @_;
    my $html = <<"    END_HTML";
<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:kinetic="http://www.kineticode.com/rest" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:fo="http://www.w3.org/1999/XSL/Format">
  <head>
    <link rel="stylesheet" href="/css/rest.css"/>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>$title</title>
    END_HTML

    if ( $title =~ /instances/ ) {
        $html .= <<"        END_HTML";
    <script language="JavaScript1.2" type="text/javascript" src="/js/search.js"></script>
  </head>
  <body onload="document.search_form.search.focus()">
        END_HTML
    }
    else {
        $html .= <<"        END_HTML";
  </head>
  <body>
        END_HTML
    }
    return $html;
}

##############################################################################

=head3 search_form

  my $form = $test->search_form($class_key, $search_string, $limit, $order_by);

This method returns the HTML form generated by the XSLT.

=cut

sub search_form {
    my ( $test, $class_key, $search, $limit, $order_by ) = @_;
    my $domain = $test->domain;
    my $path   = $test->path;
    return <<"    END_FORM";
    <div class="search_form">
      <form method="get" name="search_form" onsubmit="javascript:do_search(this); return false" id="search_form">
        <input type="hidden" name="class_key" value="$class_key" />
        <input type="hidden" name="domain" value="$domain" />
        <input type="hidden" name="path" value="$path" />
        <table>
          <tr>
            <td>Search:</td>
            <td>
              <input type="text" name="search" value="$search" />
            </td>
          </tr>
          <tr>
            <td>Limit:</td>
            <td>
              <input type="text" name="limit" value="$limit" />
            </td>
          </tr>
          <tr>
            <td>Order by:</td>
            <td>
              <input type="text" name="order_by" value="$order_by" />
            </td>
          </tr>
          <tr>
            <td>Sort order:</td>
            <td>
              <select name="sort_order">
                <option value="ASC">Ascending</option>
                <option value="DESC">Descending</option>
              </select>
            </td>
          </tr>
          <tr>
            <td colspan="2">
              <input type="submit" value="Search" onclick="javascript:do_search(this)" />
            </td>
          </tr>
        </table>
      </form>
    </div>
    END_FORM
}

##############################################################################

=head3 instance_table

  my $table = $test->instance_table($query_string, @objects);

This method returns the instance table that the XSLT generates.  It expects to
know which query string (if any) is required and a list of Kinetic objects.

Internally it calls a C<desired_attributes> method to return a list of the
attributes which will be included in the instance table.

=cut

sub instance_table {
    my ( $test, $query, @objects ) = @_;
    my $url = $test->url;
    $query = "?$query" if $query;
    my $table      = '<div class="listing"><table><tr>';
    my @attributes = $test->desired_attributes;
    foreach my $attr (@attributes) {
        $table .= qq{<th class="header">$attr</th>};
    }
    $table .= '</tr>';
    my $odd_even = 0;
    foreach my $object (@objects) {
        my $uuid = $object->uuid;
        $odd_even = ! $odd_even || 0; # creating alternating row colors
        $table .= qq{<tr class="row_$odd_even">};
        foreach my $attr (@attributes) {
            my $value = ( $object->$attr || '' );
            $table .= <<"            END_ATTR";
    <td>
    <a href="${url}one/lookup/uuid/$uuid$query">$value</a>
    </td>
            END_ATTR
        }
        $table .= '</tr>';
    }
    $table .= '</table></div>';
    return $table;
}

1;
