? t/parents.t
? t/subclass.t
Index: lib/Module/Build/Authoring.pod
===================================================================
RCS file: /cvsroot/module-build/Module-Build/lib/Module/Build/Authoring.pod,v
retrieving revision 1.1
diff -u -r1.1 Authoring.pod
--- lib/Module/Build/Authoring.pod	6 Dec 2004 13:38:08 -0000	1.1
+++ lib/Module/Build/Authoring.pod	7 Dec 2004 02:12:02 -0000
@@ -162,6 +162,16 @@
 the body of installed modules, and facilitates correct dependency
 checking on binary/packaged distributions of the module.
 
+=item build_class
+
+The Module::Build class to use in the build script. Defaults to
+"Module::Build" or the class name passed to or created by a call to
+C<subclass()>. This property is useful if you're writing a custom
+Module::Build subclass and have a bootstrapping problem--that is,
+your subclass requires modules that may not be installed when
+C<perl Build.PL> is executed, but you've listed in C<build_requires>
+so that they should be available when C<./Build> is executed.
+
 =item c_source
 
 An optional C<c_source> argument specifies a directory which contains
@@ -809,6 +819,23 @@
 Any directories that need to be created in order to perform the
 copying will be automatically created.
 
+=item add_property()
+
+  package My::Builder;
+  use base 'Module::Build';
+  __PACKAGE->add_property('foo');
+  __PACKAGE->add_property('bar' => 1);
+  __PACKAGE->add_property('hash' => {});
+
+This method adds new properties to subclasses of Module::Build. By using
+C<add_property()>, you get the benefit of property conflict checking, accessor
+method generation, and command-line argument support, just like the
+Module::Build properties.
+
+An optional second argument specifies a default value for your property. Note
+that if you pass in a hash or array reference, then your property will be
+treated as such by Module::Build.
+
 =item create_build_script()
 
 Creates an executable script called C<Build> in the current directory
@@ -1127,6 +1154,11 @@
 the Build script, so that My::Builder can be found when running build
 actions.
 
+If you need to add new properties to your subclass, and want them to be
+supported for passing to C<new()> or as command-line parameters, as well
+as to have accessor methods generated for them, use the C<add_property>
+method to add them to your class.
+
 For very small additions, Module::Build provides a C<subclass()>
 method that lets you subclass Module::Build more conveniently, without
 creating a separate file for your module:
Index: lib/Module/Build/Base.pm
===================================================================
RCS file: /cvsroot/module-build/Module-Build/lib/Module/Build/Base.pm,v
retrieving revision 1.358
diff -u -r1.358 Base.pm
--- lib/Module/Build/Base.pm	6 Dec 2004 23:03:08 -0000	1.358
+++ lib/Module/Build/Base.pm	7 Dec 2004 02:12:03 -0000
@@ -80,28 +80,16 @@
   my $config = delete $input{config} || {};
 
   my $self = bless {
-		    args => {%$args},
-		    config => {%Config, %$config},
-		    properties => {
-				   module_name     => '',
-				   build_script    => 'Build',
-				   base_dir        => $package->cwd,
-				   config_dir      => '_build',
-				   blib            => 'blib',
-				   requires        => {},
-				   recommends      => {},
-				   build_requires  => {},
-				   conflicts       => {},
-				   mb_version      => $Module::Build::VERSION,
-				   build_elements  => [qw( PL support pm xs pod script )],
-				   installdirs     => 'site',
-				   install_path    => {},
-				   include_dirs    => [],
-				   recurse_into    => [],
-				   %input,
-				  },
-		   }, $package;
+      args => {%$args},
+      config => {%Config, %$config},
+      properties => {
+          base_dir   => $package->cwd,
+          mb_version => $Module::Build::VERSION,
+          %input,
+      },
+  }, $package;
 
+  $self->_set_defaults;
   my ($p, $c) = ($self->{properties}, $self->{config});
 
   # The following warning could be unnecessary if the user is running
@@ -115,7 +103,7 @@
   $p->{bindoc_dirs} ||= [ "$p->{blib}/script" ];
   $p->{libdoc_dirs} ||= [ "$p->{blib}/lib", "$p->{blib}/arch" ];
 
-  $p->{dist_author} = [ $p->{dist_author} ] if exists $p->{dist_author} and not ref $p->{dist_author};
+  $p->{dist_author} = [ $p->{dist_author} ] if defined $p->{dist_author} and not ref $p->{dist_author};
 
   # Synonyms
   $p->{requires} = delete $p->{prereq} if exists $p->{prereq};
@@ -123,7 +111,7 @@
 
   $self->add_to_cleanup( @{delete $p->{add_to_cleanup}} )
     if $p->{add_to_cleanup};
-  
+
   return $self;
 }
 
@@ -434,66 +422,173 @@
 }
 
 {
-  # XXX huge hack alert - will revisit this later
-  my %valid_properties = map {$_ => 1}
-    qw(
-       module_name
-       dist_name
-       dist_version
-       dist_version_from
-       dist_author
-       dist_abstract
-       requires
-       recommends
-       license
-       pm_files
-       xs_files
-       pod_files
-       PL_files
-       scripts
-       script_files
-       test_files
-       recursive_test_files
-       perl
-       config_dir
-       blib
-       has_config_data
-       build_script
-       build_elements
-       install_sets
-       install_path
-       install_base
-       installdirs
-       destdir
-       debugger
-       verbose
-       c_source
-       autosplit
-       create_makefile_pl
-       create_readme
-       pollute
-       extra_compiler_flags
-       include_dirs
-       bindoc_dirs
-       libdoc_dirs
-       get_options
-       recurse_into
-      );
-
-  sub valid_property { exists $valid_properties{$_[1]} }
-
-  sub valid_properties { keys %valid_properties }
-
-  # Create an accessor for each property that doesn't already have one
-  foreach my $property (keys %valid_properties) {
-      next if __PACKAGE__->can($property);
-      no strict 'refs';
-      *{$property} = sub {
-          my $self = shift;
-          $self->{properties}{$property} = shift if @_;
-          return $self->{properties}{$property};
-      };
-  }
+    my %valid_properties = ( __PACKAGE__ => {} );
+    my %additive_properties;
+
+    sub valid_property {
+        my $class = shift->_prop_class;
+        exists $valid_properties{$class}->{$_[0]}
+    }
+
+    sub valid_properties {
+        my $class = shift->_prop_class;
+        keys %{ $valid_properties{$class} };
+    }
+
+    sub array_properties {
+        my $class = shift->_prop_class;
+        return unless exists $additive_properties{$class}->{ARRAY};
+        return @{$additive_properties{$class}->{ARRAY}};
+    }
+
+    sub hash_properties {
+        my $class = shift->_prop_class;
+        return unless exists $additive_properties{$class}->{'HASH'};
+        return @{$additive_properties{$class}->{'HASH'}};
+    }
+
+    sub add_property {
+        my ($class, $property, $default) = @_;
+        unless (exists $valid_properties{$class}) {
+            # Set it up with the properties from the parent classes, first.
+            for my $parent (reverse $class->mb_parents) {
+                $valid_properties{$class}->{$_} = $valid_properties{$parent}->{$_}
+                  for keys %{ $valid_properties{$parent} };
+            }
+        }
+
+        return $class unless $property;
+
+        die qq{Property "$property" already exists\n}
+          if $class->valid_property($property);
+        if (my $type = ref $default) {
+            push @{$additive_properties{$class}->{$type}}, $property;
+        }
+
+        $valid_properties{$class}->{$property} = $default;
+        return $class if $class->can($property);
+        no strict 'refs';
+        *{"$class\::$property"} = sub {
+            my $self = shift;
+            $self->{properties}{$property} = shift if @_;
+            return $self->{properties}{$property};
+        };
+        return $class;
+    }
+
+    sub _prop_class {
+        my $class = ref $_[0] || $_[0];
+        unless (exists $valid_properties{$class}) {
+            if (my @parents = $class->mb_parents) {
+                do {
+                    $class = shift @parents;
+                } until (exists $valid_properties{$class} || !@parents);
+            }
+        }
+        return $class;
+    }
+
+    sub _set_defaults {
+        my $self = shift;
+        my $class = $self->_prop_class;
+	# Set the build class.
+	$self->{build_properties}{build_class} ||= ref $self;
+        for my $prop ($self->valid_properties) {
+            $self->{properties}{$prop} = $valid_properties{$class}->{$prop}
+              unless exists $self->{properties}{$prop};
+        }
+        # Copy defaults for arrays any arrays.
+        for my $prop ($self->array_properties) {
+            $self->{properties}{$prop} = [@{$valid_properties{$class}->{$prop}}]
+              unless exists $self->{properties}{$prop};
+        }
+        # Copy defaults for arrays any hashes.
+        for my $prop ($self->hash_properties) {
+            $self->{properties}{$prop} = {%{$valid_properties{$class}->{$prop}}}
+              unless exists $self->{properties}{$prop};
+        }
+    }
+
+}
+
+# Add the default properties.
+__PACKAGE__->add_property(module_name => '');
+__PACKAGE__->add_property(build_script => 'Build');
+__PACKAGE__->add_property(config_dir => '_build');
+__PACKAGE__->add_property(blib => 'blib');
+__PACKAGE__->add_property(requires => {});
+__PACKAGE__->add_property(recommends => {});
+__PACKAGE__->add_property(build_requires => {});
+__PACKAGE__->add_property(conflicts => {});
+__PACKAGE__->add_property('mb_version');
+__PACKAGE__->add_property(build_elements => [qw(PL support pm xs pod script)]);
+__PACKAGE__->add_property(installdirs => 'site');
+__PACKAGE__->add_property(install_path => {});
+__PACKAGE__->add_property(include_dirs => []);
+__PACKAGE__->add_property('config', {});
+__PACKAGE__->add_property(recurse_into => []);
+__PACKAGE__->add_property(build_class => 'Module::Build');
+__PACKAGE__->add_property($_) for qw(
+   base_dir
+   dist_name
+   dist_version
+   dist_version_from
+   dist_author
+   dist_abstract
+   license
+   pm_files
+   xs_files
+   pod_files
+   PL_files
+   scripts
+   script_files
+   test_files
+   recursive_test_files
+   perl
+   has_config_data
+   install_sets
+   install_base
+   destdir
+   debugger
+   verbose
+   c_source
+   autosplit
+   create_makefile_pl
+   create_readme
+   pollute
+   extra_compiler_flags
+   bindoc_dirs
+   libdoc_dirs
+   get_options
+);
+
+sub mb_parents {
+    # Code borrowed from Class::ISA.
+    my @in_stack = (shift);
+    my %seen = ($in_stack[0] => 1);
+
+    my ($current, @out);
+    while (@in_stack) {
+        next unless defined($current = shift @in_stack)
+          && $current->isa('Module::Build::Base');
+        push @out, $current;
+        next if $current eq 'Module::Build::Base';
+        no strict 'refs';
+        unshift @in_stack,
+          map {
+              my $c = $_; # copy, to avoid being destructive
+              substr($c,0,2) = "main::" if substr($c,0,2) eq '::';
+              # Canonize the :: -> main::, ::foo -> main::foo thing.
+              # Should I ever canonize the Foo'Bar = Foo::Bar thing?
+              $seen{$c}++ ? () : $c;
+          } @{"$current\::ISA"};
+
+        # I.e., if this class has any parents (at least, ones I've never seen
+        # before), push them, in order, onto the stack of classes I need to
+        # explore.
+    }
+    shift @out;
+    return @out;
 }
 
 sub extra_compiler_flags {
@@ -544,7 +639,7 @@
 sub dist_name {
   my $self = shift;
   my $p = $self->{properties};
-  return $p->{dist_name} if exists $p->{dist_name};
+  return $p->{dist_name} if defined $p->{dist_name};
   
   die "Can't determine distribution name, must supply either 'dist_name' or 'module_name' parameter"
     unless $p->{module_name};
@@ -558,7 +653,7 @@
   my ($self) = @_;
   my $p = $self->{properties};
   
-  return $p->{dist_version} if exists $p->{dist_version};
+  return $p->{dist_version} if defined $p->{dist_version};
   
   if ($self->module_name) {
     $p->{dist_version_from} ||= join( '/', 'lib', split '::', $self->module_name ) . '.pm';
@@ -580,7 +675,7 @@
   my ($self, $part) = @_;
   my $p = $self->{properties};
   my $member = "dist_$part";
-  return $p->{$member} if exists $p->{$member};
+  return $p->{$member} if defined $p->{$member};
   
   return unless $p->{dist_version_from};
   my $fh = IO::File->new($p->{dist_version_from}) or return;
@@ -964,7 +1059,7 @@
 sub print_build_script {
   my ($self, $fh) = @_;
   
-  my $build_package = ref($self);
+  my $build_package = $self->build_class;
   
   my %q = map {$_, $self->$_()} qw(config_dir base_dir);
   $q{base_dir} = Win32::GetShortPathName($q{base_dir}) if $^O eq 'MSWin32';
@@ -1101,8 +1196,6 @@
         die "Option specification '$k' conflicts with a " . ref $self
           . " option of the same name"
           if $self->valid_property($k);
-        # XXX Are there other options we should check? Contents of
-        # %additive elsewhere in this package?
         push @specs, $k . (defined $v->{type} ? $v->{type} : '');
         push @specs, $v->{store} if exists $v->{store};
         $args->{$k} = $v->{default} if exists $v->{default};
@@ -1155,11 +1248,8 @@
   }
   $args{ARGV} = \@argv;
 
-  # 'config' and 'install_path' are additive by hash key
-  my %additive = map {$_, 1} qw(config install_path);
-
   # Hashify these parameters
-  for (keys %additive) {
+  for ($self->hash_properties) {
     next unless exists $args{$_};
     my %hash;
     $args{$_} ||= [];
@@ -1171,25 +1261,25 @@
     }
     $args{$_} = \%hash;
   }
-  
+
   if ($args{makefile_env_macros}) {
     require Module::Build::Compat;
     %args = (%args, Module::Build::Compat->makefile_to_build_macros);
   }
-  
+
   return \%args, $action;
 }
 
 sub merge_args {
   my ($self, $action, %args) = @_;
-  my %additive = (config => $self->{config},
-		  install_path => $self->{properties}{install_path});
-
   $self->{action} = $action if defined $action;
 
+  my %additive = map { $_ => 1 } $self->hash_properties;
+
   # Extract our 'properties' from $cmd_args, the rest are put in 'args'.
   while (my ($key, $val) = each %args) {
-    my $add_to = ($additive{$key} ? $additive{$key}
+    my $add_to = ( $key eq 'config' ? $self->{config}
+                  : $additive{$key} ? $self->{properties}{$key}
 		  : $self->valid_property($key) ? $self->{properties}
 		  : $self->{args});
 
Index: t/basic.t
===================================================================
RCS file: /cvsroot/module-build/Module-Build/t/basic.t,v
retrieving revision 1.33
diff -u -r1.33 basic.t
--- t/basic.t	15 Nov 2004 19:58:42 -0000	1.33
+++ t/basic.t	7 Dec 2004 02:12:03 -0000
@@ -2,7 +2,7 @@
 
 use strict;
 use Test;
-BEGIN { plan tests => 41 }
+BEGIN { plan tests => 43 }
 use Module::Build;
 ok(1);
 
@@ -21,6 +21,7 @@
   my $build = new Module::Build( module_name => 'ModuleBuildOne' );
   ok $build;
   ok $build->module_name, 'ModuleBuildOne';
+  ok $build->build_class, 'Module::Build';
   ok $build->dist_name, 'ModuleBuildOne';
   
   $build = Module::Build->new( dist_name => 'ModuleBuildOne', dist_version => 7 );
@@ -152,8 +153,10 @@
     (
      module_name => 'ModuleBuildOne',
      dist_author => 'Foo Meister <foo@example.com>',
+     build_class => 'My::Big::Fat::Builder',
     );
   ok $build;
   ok ref($build->dist_author);
   ok $build->dist_author->[0], 'Foo Meister <foo@example.com>';
+  ok $build->build_class, 'My::Big::Fat::Builder';
 }
--- /dev/null	Mon Dec  6 18:09:55 2004
+++ t/parents.t	Mon Dec  6 17:47:35 2004
@@ -0,0 +1,57 @@
+use strict;
+use Test;
+BEGIN { plan tests => 27 }
+use Module::Build;
+ok(1);
+
+package Foo;
+sub foo;
+
+package MySub1;
+use base 'Module::Build';
+
+package MySub2;
+use base 'MySub1';
+
+package MySub3;
+use base qw(MySub2 Foo);
+
+package MyTest;
+use base 'Module::Build';
+
+package MyBulk;
+use base qw(MySub2 MyTest);
+
+package main;
+
+ok my @parents = MySub1->mb_parents;
+# There will be at least one platform class in between.
+ok @parents >= 2;
+# They should all inherit from Module::Build::Base;
+ok ! grep { !$_->isa('Module::Build::Base') } @parents;
+ok $parents[0], 'Module::Build';
+ok $parents[-1], 'Module::Build::Base';
+
+ok @parents = MySub2->mb_parents;
+ok @parents >= 3;
+ok ! grep { !$_->isa('Module::Build::Base') } @parents;
+ok $parents[0], 'MySub1';
+ok $parents[1], 'Module::Build';
+ok $parents[-1], 'Module::Build::Base';
+
+ok @parents = MySub3->mb_parents;
+ok @parents >= 4;
+ok ! grep { !$_->isa('Module::Build::Base') } @parents;
+ok $parents[0], 'MySub2';
+ok $parents[1], 'MySub1';
+ok $parents[2], 'Module::Build';
+ok $parents[-1], 'Module::Build::Base';
+
+ok @parents = MyBulk->mb_parents;
+ok @parents >= 5;
+ok ! grep { !$_->isa('Module::Build::Base') } @parents;
+ok $parents[0], 'MySub2';
+ok $parents[1], 'MySub1';
+ok $parents[2], 'Module::Build';
+ok $parents[-2], 'Module::Build::Base';
+ok $parents[-1], 'MyTest';
--- /dev/null	Mon Dec  6 18:09:55 2004
+++ t/subclass.t	Mon Dec  6 18:09:54 2004
@@ -0,0 +1,104 @@
+use strict;
+use Test;
+BEGIN { plan tests => 37 }
+use Module::Build;
+ok(1);
+
+use File::Spec;
+use Cwd;
+require File::Spec->catfile('t', 'common.pl');
+
+######################### End of black magic.
+
+ok $INC{'Module/Build.pm'}, '/blib/', "Make sure Module::Build was loaded from blib/";
+
+package MBSub;
+use Test;
+use vars qw($VERSION @ISA);
+@ISA = qw(Module::Build);
+$VERSION = 0.01;
+
+# Add a new property.
+ok(__PACKAGE__->add_property('foo'));
+# Add a new property with a default value.
+ok(__PACKAGE__->add_property('bar', 'hey'));
+# Add a hash property.
+ok(__PACKAGE__->add_property('hash', {}));
+
+
+# Catch an exception adding an existing property.
+eval { __PACKAGE__->add_property('module_name')};
+ok my $err = $@;
+ok $err =~ /Property "module_name" already exists/;
+
+1;
+
+package MBSub2;
+use Test;
+use vars qw($VERSION @ISA);
+@ISA = qw(Module::Build);
+$VERSION = 0.01;
+
+# Add a new property with a different default value than MBSub has.
+ok(__PACKAGE__->add_property('bar', 'yow'));
+1;
+
+package main;
+
+BEGIN { chdir 't'; }
+ok my $build = MBSub->new( module_name => 'ModuleBuildOne' );
+ok $build->isa('Module::Build');
+ok $build->isa('MBSub');
+ok $build->valid_property('foo');
+# Ppbbbblllltttt! Stupid Test::ok doesn't know that a code reference
+# is a true value. Duh! Turns out it executes it and checks its return
+# value, instead. D'oh!
+ok !!$build->can('module_name');
+
+# Check foo property.
+ok !!$build->can('foo');
+ok ! $build->foo;
+ok $build->foo(1);
+ok $build->foo;
+
+# Check bar property.
+ok !!$build->can('bar');
+ok $build->bar, 'hey';
+ok $build->bar('you');
+ok $build->bar, 'you';
+
+# Check hash property.
+ok $build = MBSub->new(
+    module_name => 'ModuleBuildOne',
+    hash        => { foo => 'bar', bin => 'foo'}
+);
+
+ok !!$build->can('hash');
+ok ref $build->hash, 'HASH';
+ok $build->hash->{foo}, 'bar';
+ok $build->hash->{bin}, 'foo';
+
+# Check hash property passed via the command-line.
+{
+     local @ARGV = (
+         '--hash', 'foo=bar',
+         '--hash', 'bin=foo',
+     );
+     ok $build = MBSub->new(
+         module_name => 'ModuleBuildOne',
+     );
+}
+
+ok !!$build->can('hash');
+ok ref $build->hash, 'HASH';
+ok $build->hash->{foo}, 'bar';
+ok $build->hash->{bin}, 'foo';
+
+# Make sure that a different subclass with the same named property has a
+# different default.
+ok $build = MBSub2->new( module_name => 'ModuleBuildOne' );
+ok $build->isa('Module::Build');
+ok $build->isa('MBSub2');
+ok $build->valid_property('bar');
+ok !!$build->can('bar');
+ok $build->bar, 'yow';
