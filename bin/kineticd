#!/usr/bin/perl

use strict;
use warnings;

use lib 'lib/';
use Getopt::Long;
use File::Pid;
use File::Spec ();
use aliased 'Proc::Background';
use Kinetic::Util::Exceptions qw/throw_fatal/;
use Kinetic::Util::Language;
my $LANG = Kinetic::Util::Language->get_handle;
Kinetic::Util::Context->language($LANG);
my ( $debug, $VERBOSE, $help, $conf );

sub try_to_use {
    my ( $module, $version, $reason ) = @_;
    eval "use $module $version";
    if ( my $error = $@ ) {
        throw_fatal [ '[_1] [_2] or better not available for [_3]: [_4]',
            $module, $version, $reason, $error ];
    }
}

sub localize {
    return $LANG->maketext(@_) . "\n";
}

BEGIN {
    GetOptions(
        'debug'   => \$debug,
        'verbose' => \$VERBOSE,
        'help|?'  => \$help,
        'conf=s'  => \$conf,
    );

    if ($help) {
        try_to_use( 'Pod::Usage', 1.12, 'help' );
        pod2usage( { -verbose => 2 } );
        exit;
    }

    if ( defined $conf ) {
        $ENV{KINETIC_CONF} = $conf;
    }
    $conf = $ENV{KINETIC_CONF} || '';
    unless ( -f $conf ) {

        # XXX this won't be needed for production
        throw_fatal [ 'Could not find conf file "[_1]"', $conf ];
    }
}

$ENV{KINETIC_CONF} = $conf;
use Kinetic::Util::Config qw(:all);
use Readonly;
Readonly my $LOG_DIR   => File::Spec->catfile( KINETIC_ROOT, 'logs' );
Readonly my $PID_FILE  => File::Spec->catfile( $LOG_DIR,     'kinetic.pid' );
Readonly my $ERROR_LOG => File::Spec->catfile( $LOG_DIR,     'error_log' );

if ($debug) {
    try_to_use( 'Devel::Symdump', 2, 'debug' );
    my $symbols  = Devel::Symdump->new('main');
    my $length   = 0;
    my %value_of = do {
        no strict 'refs';
        map {
            s/^main:://;
            $length = length($_) if length($_) > $length;
            $_ => &$_;
          }
          grep {/^main::[:[:upper:]_]+$/} $symbols->functions();
    };
    foreach my $constant ( sort keys %value_of ) {

        # nothing to localize
        printf "%-${length}s => %s\n", $constant, $value_of{$constant};
    }
    print localize( 'Using config file "[_1]"', $conf );
}

my $pidfile = File::Pid->new( { file => $PID_FILE } );

my $pack = __PACKAGE__;
Readonly my $LIB => File::Spec->catfile( KINETIC_ROOT, 'lib' );
print localize( 'Using lib "[_1]"', $LIB ) if $debug;

my $command = lc shift @ARGV || '';
unless ( $command =~ /^stop|start|restart$/ ) {
    die localize("You must specify stop, start, or restart");
}

if ( 'start' eq $command ) {
    start($pidfile);
}
elsif ( 'stop' eq $command ) {
    stop($pidfile);
}
elsif ( 'restart' eq $command ) {
    stop($pidfile);
    start($pidfile);
}
else {
    die "Unknown command '$command'\n";
}

sub start {
    my $pidfile = shift;
    if ( $pidfile->running ) {
        die localize( 'Process is already running as pid "[_1]"',
            $pidfile->pid );
    }
    else {
        my ($engine, @args);

        # figure out which server to start
        if ( $pack->can('SIMPLE_HOST') ) {
            $engine = 'catalyst';
            @args = ( $^X, "-I$LIB", '-M' . &ENGINE_CLASS, '-e 1' );
        }
        elsif ( $pack->can('APACHE_HTTPD') ) {
            $engine = 'apache';
            @args = ( &APACHE_HTTPD, 'graceful');#, '-f' . &APACHE_HTTPD_CONF );
        }
        else {
            die localize("Could not determine which server to run");
        }

        # start it
        print localize( 'Starting [_1] with args "[_2]"', $engine, "@args" )
            if $VERBOSE;
        my $process = Background->new(@args);
        if ( $process->alive ) {
            $pidfile->pid( $process->pid );
            $pidfile->write
              or die localize( 'Could not write pid "[_1]" to pidfile: [_2]',
                $process->pid, $! );
        }
        else {
            die localize( "Could not start process: [_1]", $? );
        }
    }
}

sub stop {
    my $pidfile = shift;
    if ( $pidfile->running ) {
        my $pid = $pidfile->pid;
        if ( kill 15, $pid ) {
            $pidfile->remove;
        }
        else {
            die localize( 'Could not stop pid "[_1]": [_2]', $pid, $? );
        }
    }
    else {
        warn localize("The Kinetic server did not appear to be running");
    }
}

__DATA__

=head1 NAME 

kineticd --  Start the Kinetic engine

=head1 SYNOPSIS

kineticd [-hdvr] [-c conf_file] [start|stop|restart]

Options:

 -h, --help     Print this page and exit.
 -?             Same as --help
 -d, --debug    Print Kinetic::Util::Config constants and their values
 -v, --verbose  Print out which engine is being started
 -c, --conf     Use the specified config file instead of $ENV{KINETIC_CONF}

Command (one of the following commands must be supplied):

 stop         Stop the engine
 start        Start the engine
 restart      Restart the engine

=head1 DESCRIPTION

C<kineticd> starts the Kinetic engine.  The C<KINETIC_CONF> environment
variable should point to the location of the desired Kinetic configuration
file.  If not, you may specify C<--conf /path/to/my/conf_file> to supply (or
override) this value.  

Note that once installed, C<KINETIC_CONF> will probably not need to be set,
nor will the C<--conf> option be necessary unless you wish a different
configuration file than the installed one.
