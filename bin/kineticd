#!/usr/bin/perl

use strict;
use warnings;

use lib 'lib/';
use Getopt::Long;
use File::Pid;
use File::Spec ();
use aliased 'Proc::Background';
use Kinetic::Util::Exceptions qw/throw_fatal/;
use Kinetic::Util::Language;
my $LANG = Kinetic::Util::Language->get_handle;
Kinetic::Util::Context->language($LANG);
my ( $DEBUG, $VERBOSE, $HELP, $CONF, $PIDFILE );

sub try_to_use {
    my ( $module, $version, $reason ) = @_;
    eval "use $module $version";
    if ( my $error = $@ ) {
        throw_fatal [
            '[_1] [_2] or better not available for [_3]: [_4]',
            $module, $version, $reason, $error
        ];
    }
}

sub localize {
    return $LANG->maketext(@_) . "\n";
}

BEGIN {
    GetOptions(
        'debug'     => \$DEBUG,
        'verbose'   => \$VERBOSE,
        'help|?'    => \$HELP,
        'conf=s'    => \$CONF,
        'pidfile=s' => \$PIDFILE,
    );

    if ($HELP) {
        try_to_use( 'Pod::Usage', 1.12, 'help' );
        pod2usage( { -verbose => 2 } );
        exit;
    }

    if ( defined $CONF ) {
        $ENV{KINETIC_CONF} = $CONF;
    }
    $CONF = $ENV{KINETIC_CONF} || '';
    unless ( -f $CONF ) {

        # XXX this won't be needed for production
        throw_fatal [ 'Could not find conf file "[_1]"', $CONF ];
    }
}

$ENV{KINETIC_CONF} = $CONF;
use Kinetic::Util::Config qw(:all);
use Readonly;
Readonly my $LOG_DIR => File::Spec->catfile( KINETIC_ROOT, 'logs' );
Readonly my $ERROR_LOG => File::Spec->catfile( $LOG_DIR, 'error_log' );

if ($DEBUG) {
    try_to_use( 'Devel::Symdump', 2, 'debug' );
    my $symbols  = Devel::Symdump->new('main');
    my $length   = 0;
    my %value_of = do {
        no strict 'refs';
        map {
            s/^main:://;
            $length = length($_) if length($_) > $length;
            $_ => &$_;
          }
          grep {/^main::[:[:upper:]_]+$/} $symbols->functions();
    };
    foreach my $constant ( sort keys %value_of ) {

        # nothing to localize
        printf "%-${length}s => %s\n", $constant, $value_of{$constant};
    }
    print localize( 'Using config file "[_1]"', $CONF );
}

my $pidfile = File::Pid->new( { file => get_pid_file_location() } );

my $pack = __PACKAGE__;
Readonly my $LIB => File::Spec->catfile( KINETIC_ROOT, 'lib' );

if ($DEBUG) {
    print localize( 'Using lib "[_1]"', $LIB );
    print qq'Using pid file "@{[$pidfile->file]}"\n';
    print qq'I think the pid is "@{[$pidfile->pid]}"\n' if $pidfile->running;
}

my $command = lc shift @ARGV || '';
unless ( $command =~ /^stop|start|restart$/ ) {
    die localize("You must specify stop, start, or restart");
}

if ( 'start' eq $command ) {
    start($pidfile);
}
elsif ( 'stop' eq $command ) {
    stop($pidfile);
}
elsif ( 'restart' eq $command ) {
    stop($pidfile);
    start($pidfile);
}
else {
    die "Unknown command '$command'\n";
}

sub start {
    my $pidfile = shift;
    if ( $pidfile->running ) {
        die localize(
            'Process is already running as pid "[_1]"',
            $pidfile->pid
        );
    }
    else {
        my ( $engine, @args );

        # figure out which server to start
        if ( $pack->can('SIMPLE_HOST') ) {
            $engine = 'catalyst';
            @args = ( $^X, "-I$LIB", '-M' . &ENGINE_CLASS, '-e 1' );
        }
        elsif ( $pack->can('APACHE_HTTPD') ) {
            $engine = 'apache';
            @args
              = ( &APACHE_HTTPD, 'start' );    #, '-f' . &APACHE_HTTPD_CONF );
        }
        else {
            die localize("Could not determine which server to run");
        }

        # start it
        print localize( 'Starting [_1] with args "[_2]"', $engine, "@args" )
          if $VERBOSE;
        my $process = Background->new(@args);
        if ( $process->alive ) {
            $pidfile->pid( $process->pid );
            unless ( $pack->can('APACHE_HTTPD') ) {
                $pidfile->write
                  or die localize(
                    'Could not write pid "[_1]" to pidfile: [_2]',
                    $process->pid, $!
                  );
            }
        }
        else {
            die localize( "Could not start process: [_1]", $? );
        }
    }
}

sub stop {
    my $pidfile = shift;
    if ( $pidfile->running ) {
        my $pid = $pidfile->pid;
        if ( kill 15, $pid ) {
            $pidfile->remove;
        }
        else {
            die localize( 'Could not stop pid "[_1]": [_2]', $pid, $? );
        }
    }
    else {
        warn localize("The Kinetic server did not appear to be running");
    }
}

sub get_pid_file_location {
    return $PIDFILE if defined $PIDFILE;
    if ( __PACKAGE__->can('SIMPLE_HOST') ) {
        return File::Spec->catfile( $LOG_DIR, 'kinetic.pid' );
    }
    elsif ( __PACKAGE__->can('APACHE_HTTPD') ) {
        my $pid_file;

        # Get the Apache PID file location from httpd.conf.
        local *HC;
        open HC, &APACHE_HTTPD_CONF
          or die "Cannot open @{[&APACHE_HTTPD_CONF]}: $!\n";
        while (<HC>) {

            # Ignore comments.
            chomp;       # no newline
            s/#.*//;     # no comments
            s/^\s+//;    # no leading white
            s/\s+$//;    # no trailing white
            next unless length;               # anything left?
            next unless /^PidFile\s+(.*)/i;
            $pid_file = $1;
            last;
        }
        close HC;
        unless ($pid_file) {

            # couldn't figure out the pid file, so we are going to try
            # and figure it out from standard apache locations
            my ($log_dir) = &APACHE_HTTPD_CONF =~ /^(.*?)conf/;
            unless ( defined $log_dir ) {
                die localize("Could not determine pid directory");
            }
            my $pid_dir = File::Spec->catdir( $log_dir, 'logs' );
            unless ( -d $pid_dir ) {
                die localize(
                    "Could not find pid directory at [_1]",
                    $pid_dir
                );
            }
            return File::Spec->catdir( $pid_dir, 'httpd.pid' );
        }
    }
    else {
        die localize("Could not determine which server to run");
    }
}
__DATA__

=head1 NAME 

kineticd --  Start the Kinetic engine

=head1 SYNOPSIS

kineticd [-hdvrp] [-c conf_file] [start|stop|restart]

Options:

 -h, --help     Print this page and exit.
 -?             Same as --help
 -d, --debug    Print Kinetic::Util::Config constants and their values
 -v, --verbose  Print out which engine is being started
 -c, --conf     Use the specified config file instead of $ENV{KINETIC_CONF}
 -p, --pidfile  Location of the pid file

Command (one of the following commands must be supplied):

 stop         Stop the engine
 start        Start the engine
 restart      Restart the engine

=head1 DESCRIPTION

C<kineticd> starts the Kinetic engine.  The C<KINETIC_CONF> environment
variable should point to the location of the desired Kinetic configuration
file.  If not, you may specify C<--conf /path/to/my/conf_file> to supply (or
override) this value.  

Note that once installed, C<KINETIC_CONF> will probably not need to be set,
nor will the C<--conf> option be necessary unless you wish a different
configuration file than the installed one.

=head1 COMMAND LINE OPTIONS

=over 4

=item * -c, --conf

This should point to the value of the C<kinetic.conf> file.  Usually this is
only needed in testing if the C<KINETIC_CONF> environment variable is not set.

=item * -p, --pidfile

Ordinarily, C<kineticd> will have no problem finding the pid file for the
server it will start.  However, if the pidfile location cannot be determined,
use this option to specify its location.

=back
