package Kinetic::Store::Parser::DB;

# $Id: Store.pm 1364 2005-03-08 03:53:03Z curtis $

# CONTRIBUTION SUBMISSION POLICY:
#
# (The following paragraph is not intended to limit the rights granted to you
# to modify and distribute this software under the terms of the GNU General
# Public License Version 2, and is only of importance to you if you choose to
# contribute your changes and enhancements to the community by submitting them
# to Kineticode, Inc.)
#
# By intentionally submitting any modifications, corrections or
# derivatives to this work, or any other work intended for use with the
# Kinetic framework, to Kineticode, Inc., you confirm that you are the
# copyright holder for those contributions and you grant Kineticode, Inc.
# a nonexclusive, worldwide, irrevocable, royalty-free, perpetual license to
# use, copy, create derivative works based on those contributions, and
# sublicense and distribute those contributions and any derivatives thereof.

=head1 Name

Kinetic::Store::Parser::DB - Parser for Kinetic search mini-language built from
code refs.

=head1 Synopsis

  use Kinetic::Store::Lexer::Code qw/lex/;
  use Kinetic::Store::Parser::DB qw/parse/;
  my $parsed = parse(lex(\@search_params), $store);

=head1 Description

This package will parse the data structure built by a Kinetic lexer and returns
a data structure that L<Kinetic::Store::DB|Kinetic::Store::DB> can use to build
where clauses.

=cut

use strict;
use warnings;

use aliased 'Kinetic::Store::Search';
use Kinetic::Util::Exceptions qw/throw_search/;
use constant OBJECT_DELIMITER => '__';

use Exporter::Tidy default => ['parse'];

##############################################################################

=head3 parse

  # ir stands for Intermediate Representation
  my $ir = parse(lex(\@search_params), $store);

This function takes a data structure returned by a Kinetic lexer and returns a
data structure suitable for the Store db interface to use to build where
clauses.  The second argument to this function is a store object.  This is used
to access the class metadata that's generated by the store to determine if
column names being used actually exist.

=cut


my @ATTRIBUTES = qw/column negated operator data/;
sub parse {
    my ($tokens, $store) = @_;
    my @parsed;
    while (my $token = shift @$tokens) {
        unless (ref $token) { # Currently, this means its 'OR'
            push @parsed => $token, parse(shift(@$tokens), $store);
        }
        elsif ('AND' eq $token->[0] && 'ARRAY' eq ref $token->[1]) {
            my $op = shift @$token;
            my $curr_parsed = parse($token, $store);
            unshift @$curr_parsed => $op;
            push @parsed => $curr_parsed;
        }
        else {
            push @parsed => _make_search_object($token, $store);
        }
    }
    return \@parsed;
}

sub _make_search_object {
    my ($token, $store) = @_;
    unless (@$token == @ATTRIBUTES) {
        # XXX convert to exception
        die "Incorrect number of token attributes.  This should not happen (@$token)(@ATTRIBUTES)";
    }
    my ($column, $negated, $operator, $value) = @$token;
    $column =~ s/\./OBJECT_DELIMITER/eg;
    unless ($store->_search_data_has_column($column)) {
        # special case for searching on a contained object id ...
        my $id_column = $column . OBJECT_DELIMITER . 'id';
        unless ($store->_search_data_has_column($id_column)) {
            throw_search [
                "Don't know how to search for ([_1] [_2] [_3] [_4]): [_5]",
                $column, $negated, $operator, $value,
                "Unknown column '$column'"
            ];
        }
        $column = $id_column;
        $value = 
            'ARRAY' eq ref $value ? [map $_->id => @$value] 
          : ref $value            ? $value->id
          : die "Object key ($id_column) must point to an object, not a scalar ($value)";
    }
    return Search->new( 
        operator => $operator,
        negated  => $negated,
        data     => $value,
        column   => $column,
    );
}

1;

__END__

##############################################################################

=head1 Copyright and License

Copyright (c) 2004-2005 Kineticode, Inc. <info@kineticode.com>

This work is made available under the terms of Version 2 of the GNU General
Public License. You should have received a copy of the GNU General Public
License along with this program; if not, download it from
L<http://www.gnu.org/licenses/gpl.txt> or write to the Free Software
Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

This work is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
A PARTICULAR PURPOSE. See the GNU General Public License Version 2 for more
details.

=cut
