package Kinetic::Meta::DataTypes;

# $Id$

# CONTRIBUTION SUBMISSION POLICY:
#
# (The following paragraph is not intended to limit the rights granted to you
# to modify and distribute this software under the terms of the GNU General
# Public License Version 2, and is only of importance to you if you choose to
# contribute your changes and enhancements to the community by submitting them
# to Kineticode, Inc.)
#
# By intentionally submitting any modifications, corrections or
# derivatives to this work, or any other work intended for use with the
# Kinetic framework, to Kineticode, Inc., you confirm that you are the
# copyright holder for those contributions and you grant Kineticode, Inc.
# a nonexclusive, worldwide, irrevocable, royalty-free, perpetual license to
# use, copy, create derivative works based on those contributions, and
# sublicense and distribute those contributions and any derivatives thereof.

use strict;

use version;
our $VERSION = version->new('0.0.1');

use Kinetic::Meta::Type;
use OSSP::uuid;
use Data::Types;
use Kinetic::DateTime;
use Kinetic::Util::Exceptions qw(throw_invalid);
use version;

=head1 Name

Kinetic::Meta::DataTypes - Kinetic data type definition

=head1 Synopsis

  package Kinetic::Foo;
  use strict;
  use base 'Kinetic';

  BEGIN {
      my $cm = Kinetic::Meta->new( key => 'foo );
      $cm->add_attribute( name => 'bar',
                          type => 'bool' );
     $cm->build;
  }

=head1 Description

This module handles the definition of data types used by Kinetic. It should
never be used directly. Consult L<Kinetic::Meta|Kinetic::Meta> and
L<Class::Meta|Class::Meta> for details on creating new Kinetic classes with
attributes of the types defined by this module.

=cut

sub _make_isa_check {
    my $pkg = shift;
    return [ sub {
        return unless defined $_[0];
        UNIVERSAL::isa($_[0], $pkg)
          or throw_invalid(['Value "[_1]" is not a valid [_2] object',
                            $_[0], $pkg]);
    } ];
};

Kinetic::Meta::Type->class_validation_generator(\&_make_isa_check);

##############################################################################

=head1 Data Types

The Data types defined by this module are:

=over 4

=item uuid

A globally unique identifier as generated by OSSP::uuid.

=cut

Kinetic::Meta::Type->add(
    key     => 'uuid',
    name    => 'Universally Unique Identifier',
    check   => sub {
        OSSP::uuid->new->import(str => $_[0])
            or throw_invalid(['Value "[_1]" is not a UUID', $_[0]]);
    }
);

=item string

A Perl string, decoded to its internal, utf8 format.

=cut

Kinetic::Meta::Type->add(
    key     => 'string',
    name    => 'String',
    check   => sub {
        return unless ref $_[0];
        throw_invalid([ 'Value "[_1]" is not a string', $_[0] ]);
    }
);

##############################################################################

=item whole

A whole number. Throws a Fatal::Invalid exception if the value is not a whole
number.

=cut

Kinetic::Meta::Type->add(
    key     => 'whole',
    name    => 'Whole Number',
    check   => sub {
        return unless defined $_[0];
        Data::Types::is_whole($_[0])
          or throw_invalid([ 'Value "[_1]" is not a whole number', $_[0] ]);
    }
);

##############################################################################

=item bool

A boolean value.

=cut

use Class::Meta::Types::Boolean;

##############################################################################

=item datetime

A Kinetic::DateTime object.

=cut

my $utc = DateTime::TimeZone::UTC->new;
Kinetic::Meta::Type->add(
    key     => 'datetime',
    name    => 'DateTime',
    raw     => sub { ref $_[0]
                       ? shift->clone->set_time_zone($utc)->iso8601
                       : shift
                   },
    bake    => sub { Kinetic::DateTime->new_from_iso8601(shift) },
    check   => 'Kinetic::DateTime',
);

##############################################################################

=item user

A Kinetic::Party::Person::User object.

=cut

Kinetic::Meta::Type->add(
    key     => 'user',
    name    => 'User',
    check   => 'Kinetic::Party::Person::User',
);

##############################################################################

=item state

A Kinetic::Util::State object.

=cut

Kinetic::Meta::Type->add(
    key     => 'state',
    name    => 'State',
    raw     => sub { ref $_[0] ? shift->value : shift },
    bake    => sub { Kinetic::Util::State->new(shift) },
    check   => sub {
        UNIVERSAL::isa($_[0], 'Kinetic::Util::State')
            or throw_invalid(['Value "[_1]" is not a valid [_2] object',
                              $_[0], 'Kinetic::Util::State']);
        throw_invalid(['Cannot assign permanent state'])
          if $_[0] == Kinetic::Util::State->PERMANENT;
    }
);

##############################################################################

=item version

A L<version|version> object.

=cut

Kinetic::Meta::Type->add(
    key   => 'version',
    name  => 'Version',
    raw   => sub { ref $_[0] ? shift->stringify : shift },
    bake  => sub { version->new(shift) },
    check => 'version',
);

=back

=cut

1;
__END__

##############################################################################

=head1 Copyright and License

Copyright (c) 2004-2006 Kineticode, Inc. <info@kineticode.com>

This work is made available under the terms of Version 2 of the GNU General
Public License. You should have received a copy of the GNU General Public
License along with this program; if not, download it from
L<http://www.gnu.org/licenses/gpl.txt> or write to the Free Software
Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

This work is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
A PARTICULAR PURPOSE. See the GNU General Public License Version 2 for more
details.

=cut
