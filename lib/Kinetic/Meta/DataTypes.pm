package Kinetic::Meta::DataTypes;

# $Id$

# CONTRIBUTION SUBMISSION POLICY:
#
# (The following paragraph is not intended to limit the rights granted to you
# to modify and distribute this software under the terms of the GNU General
# Public License Version 2, and is only of importance to you if you choose to
# contribute your changes and enhancements to the community by submitting them
# to Kineticode, Inc.)
#
# By intentionally submitting any modifications, corrections or
# derivatives to this work, or any other work intended for use with the
# Kinetic framework, to Kineticode, Inc., you confirm that you are the
# copyright holder for those contributions and you grant Kineticode, Inc.
# a nonexclusive, worldwide, irrevocable, royalty-free, perpetual license to
# use, copy, create derivative works based on those contributions, and
# sublicense and distribute those contributions and any derivatives thereof.

use strict;

use version;
our $VERSION = version->new('0.0.1');

use Kinetic::Meta::Type;
use Kinetic::Util::Functions qw(:ean);
use OSSP::uuid;
use Data::Types;
use Kinetic::Util::Exceptions qw(throw_invalid);

=head1 Name

Kinetic::Meta::DataTypes - Kinetic data type definition

=head1 Synopsis

  package Kinetic::Foo;
  use strict;
  use base 'Kinetic';

  BEGIN {
      my $km = Kinetic::Meta->new( key => 'foo' );
      $km->add_attribute(
          name => 'bar',
          type => 'bool',
      );
      $km->build;
  }

=head1 Description

This module handles the definition of fundamental data types used by TKP. As
these data types are loaded by TKP and are always available for use, this
module should never be used directly. Other data types may be loaded from the
modules in the Kinetic::DataType name space. Classes that inherit from
L<Kinetic|Kinetic> and are defined by L<Kinetic::Meta|Kinetic::Meta> are also
available as data types, referenceable by their key names.

Consult L<Kinetic::Meta|Kinetic::Meta> and L<Class::Meta|Class::Meta> for
details on creating new Kinetic classes with attributes of the types defined
by this module.

=cut

sub _make_isa_check {
    my $pkg = shift;
    return [ sub {
        return unless defined $_[0];
        UNIVERSAL::isa($_[0], $pkg)
          or throw_invalid(['Value "[_1]" is not a valid [_2] object',
                            $_[0], $pkg]);
    } ];
};

Kinetic::Meta::Type->class_validation_generator(\&_make_isa_check);

##############################################################################

=head1 Data Types

The Data types defined by this module are:

=over 4

=item uuid

A globally unique identifier as generated by OSSP::uuid.

=cut

Kinetic::Meta::Type->add(
    key     => 'uuid',
    name    => 'Universally Unique Identifier',
    check   => sub {
        OSSP::uuid->new->import(str => $_[0])
            or throw_invalid(['Value "[_1]" is not a UUID', $_[0]]);
    }
);

##############################################################################

=item string

A Perl string, decoded to its internal, utf8 format.

=cut

Kinetic::Meta::Type->add(
    key     => 'string',
    name    => 'String',
    check   => sub {
        return unless ref $_[0];
        throw_invalid([ 'Value "[_1]" is not a string', $_[0] ]);
    }
);

##############################################################################

=item integer

=item int

An integer. Throws a Fatal::Invalid exception if the value is not a whole
number.

=cut

Kinetic::Meta::Type->add(
    key     => 'integer',
    alias   => 'int',
    name    => 'Integer',
    check   => sub {
        return unless defined $_[0];
        Data::Types::is_int($_[0])
          or throw_invalid([ 'Value "[_1]" is not an integer', $_[0] ]);
    }
);

##############################################################################

=item whole

A whole number, which is to say any integer greater than or equal to 0. Throws
a Fatal::Invalid exception if the value is not a whole number.

=cut

Kinetic::Meta::Type->add(
    key     => 'whole',
    name    => 'Whole Number',
    check   => sub {
        return unless defined $_[0];
        Data::Types::is_whole($_[0])
          or throw_invalid([ 'Value "[_1]" is not a whole number', $_[0] ]);
    }
);

##############################################################################

=item posint

A positive integer. Throws a Fatal::Invalid exception if the value is not a
posint number.

=cut

Kinetic::Meta::Type->add(
    key     => 'posint',
    name    => 'Posint Number',
    check   => sub {
        return unless defined $_[0];
        Data::Types::is_count($_[0])
          or throw_invalid([ 'Value "[_1]" is not a positive integer', $_[0] ]);
    }
);

##############################################################################

=item bool

A boolean value.

=cut

use Class::Meta::Types::Boolean;

##############################################################################

=item binary

Binary data. Attributes of this type should be used to store relatively small
quantities of binary data, such as small Web images and the like. Larger
quantities of binary data should be stored in blob attributes (TBD).

=cut

Kinetic::Meta::Type->add(
    key   => 'binary',
    name  => 'Binary Data',
);

##############################################################################

=item version

A L<version|version> object.

=cut

Kinetic::Meta::Type->add(
    key   => 'version',
    name  => 'Version',
    raw   => sub { ref $_[0] ? shift->stringify : shift },
    bake  => sub { version->new(shift) },
    check => 'version',
);

##############################################################################

=item operator

Operator strings. Allowable operators are:

=over

=item ==

=item E<gt>

=item E<lt>

=item E<gt>=

=item E<lt>=

=item !=

=item eq

=item ne

=item gt

=item lt

=item ge

=item le

=item =~

=item !~

=back

=cut

my %ops = ( map { $_ => undef } qw(== > < >= <= != eq ne gt lt ge le =~ !~) );

Kinetic::Meta::Type->add(
    key   => 'operator',
    name  => 'Operator',
    check => sub {
        throw_invalid( [ 'Value "[_1]" is not a valid operator', $_[0] ] )
            unless exists $ops{ $_[0] };
    },
);

##############################################################################

=item attribute

L<Kinetic::Meta::Attribute|Kinetic::Meta::Attribute> objects.

=cut

Kinetic::Meta::Type->add(
    key   => 'attribute',
    name  => 'Attribute',
    raw   => sub { ref $_[0] ? $_[0]->class->key . '.' . $_[0]->name : shift },
    bake  => sub { Kinetic::Meta->attr_for_key(shift) },
    check => 'Kinetic::Meta::Attribute',
);

##############################################################################

=item upc_code

=item ean_code

UPC-A or EAN bar codes. They consist 13 numerals (a 0 will be prepended to
12-digit bar codes) with a valid checksum. Some examples:

  036000291452
  0036000291452
  725272730706
  0978020137962
  4007630000116

The checksum is calculated according to this equation:

=over

=item 1

Add the digits in the even-numbered positions (second, fourth, sixth, etc.)
together and multiply by three.

=item 2

Add the digits in the odd-numbered positions excluding the first (third,
fifth, seventh, etc.) to the result.

=item 3

Subtract the result from the next-higher multiple of ten. The answer is the
check digit.

=back

See L<http://en.wikipedia.org/wiki/UPC_code> for a detailed description of UPC
and EAN codes.

=cut

Kinetic::Meta::Type->add(
    key   => 'ean_code',
    alias => 'upc_code',
    name  => 'EAN Code',
    check => sub {
        # Prepend 0 to UPC to make it a valid EAN.
        $_[0] = "0$_[0]" if length $_[0] == 12;
        throw_invalid( [ 'Value "[_1]" is not a EAN or UPC code', $_[0] ] )
            unless validate_ean($_[0]);
    },
);

=back

=cut

1;
__END__

##############################################################################

=head1 Copyright and License

Copyright (c) 2004-2006 Kineticode, Inc. <info@kineticode.com>

This work is made available under the terms of Version 2 of the GNU General
Public License. You should have received a copy of the GNU General Public
License along with this program; if not, download it from
L<http://www.gnu.org/licenses/gpl.txt> or write to the Free Software
Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

This work is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
A PARTICULAR PURPOSE. See the GNU General Public License Version 2 for more
details.

=cut
